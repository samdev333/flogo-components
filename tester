Here's a complete end-to-end setup using the Karate framework to test GraphQL APIs, compare JSON responses from mainframe and PostgreSQL data sources, and generate an HTML report. This setup includes a Maven project with the necessary structure, dependencies, and example code for testing and reporting.

Project Structure
plaintext
Copy code
src
├── main
│   └── java
└── test
    └── java
        └── examples
            ├── graphql
            │   └── test_graphql.feature
            └── BaseTest.java
pom.xml
Step 1: Add Dependencies in pom.xml
Add Karate and the Surefire plugin to your pom.xml to enable test execution and reporting:

xml
Copy code
<project>
    <modelVersion>4.0.0</modelVersion>
    <groupId>com.example</groupId>
    <artifactId>karate-graphql-test</artifactId>
    <version>1.0-SNAPSHOT</version>
    <properties>
        <maven.compiler.source>11</maven.compiler.source>
        <maven.compiler.target>11</maven.compiler.target>
    </properties>

    <dependencies>
        <!-- Karate Framework for API Testing -->
        <dependency>
            <groupId>com.intuit.karate</groupId>
            <artifactId>karate-junit5</artifactId>
            <version>1.2.0</version>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <plugin>
                <groupId>org.apache.maven.plugins</groupId>
                <artifactId>maven-surefire-plugin</artifactId>
                <version>3.0.0-M5</version>
                <configuration>
                    <argLine>-Dfile.encoding=UTF-8</argLine>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
Step 2: Create a Test Feature File (test_graphql.feature)
This feature file contains the GraphQL query test for both mainframe and PostgreSQL data sources, along with JSON comparison.

gherkin
Copy code
Feature: Test GraphQL API for Mainframe and PostgreSQL Data Sources

Background:
    # Set the URLs for mainframe and PostgreSQL endpoints (modify as needed)
    * def mainframeUrl = 'http://localhost:8080/graphql'
    * def postgresUrl = 'http://localhost:8081/graphql'

Scenario: Validate data consistency from mainframe and PostgreSQL sources
    # Step 1: Define GraphQL query to fetch customer data
    Given def query = 
    """
    {
        getCustomerData(id: "12345") {
            id
            name
            balance
        }
    }
    """

    # Step 2: Set headers for GraphQL request
    Given header Content-Type = 'application/json'
    And request { query: '#(query)' }

    # Step 3: Execute GraphQL query for mainframe data source
    Given url mainframeUrl
    When method POST
    Then status 200
    * def mainframeResponse = response

    # Step 4: Execute GraphQL query for PostgreSQL data source
    Given url postgresUrl
    And request { query: '#(query)' }
    When method POST
    Then status 200
    * def postgresResponse = response

    # Step 5: Compare responses (e.g., for JSON structure and specific fields)
    Then match mainframeResponse == postgresResponse
Step 3: Create a JUnit Test Runner (BaseTest.java)
This Java class runs the feature file and generates an HTML report.

java
Copy code
package examples;

import com.intuit.karate.junit5.Karate;

class BaseTest {
    @Karate.Test
    Karate testAll() {
        return Karate.run("classpath:examples/graphql/test_graphql.feature").relativeTo(getClass());
    }
}
Step 4: Run the Tests and Generate HTML Report
To run the tests and generate an HTML report, use the following Maven command:

sh
Copy code
mvn test
Step 5: Access the HTML Report
Once the test run is complete, the HTML report will be available at:

plaintext
Copy code
target/karate-reports/karate-summary.html
Open karate-summary.html in your browser to view the test results and JSON comparison output.

Explanation of Each Step
GraphQL Query: The feature file defines a GraphQL query to fetch customer data.
Mainframe and PostgreSQL Data Sources: Two separate requests are made to endpoints simulating mainframe and PostgreSQL data.
Response Comparison: The match statement in Karate verifies that the JSON responses are identical.
JUnit Runner: The BaseTest class runs the feature file and produces the report.
HTML Report: Karate’s built-in reporting provides a graphical HTML summary of the test steps and assertions.
Additional Customization
Database Queries: If needed, you can configure direct database access in Karate to fetch data directly for comparison.
Custom Match Rules: For fields that may vary slightly, you can use match contains or match each assertions for more flexible comparisons.
Logging: Use Karate’s built-in logging to add more visibility into request and response payloads.
This setup provides a complete framework for end-to-end test automation of your GraphQL APIs with data source comparisons and a detailed HTML report.

**********
# Story: Verify branding in Casper & General Correspondence for account without co-applicant

## Acceptance Criteria

- **AC1**: CSR can log into Casper successfully.
- **AC2**: Account must **NOT** have a co-applicant.
- **AC3**: Branding displays correctly for product description and partner.
- **AC4**: Account Summary page loads after verification.
- **AC5**: General Correspondence workflow displays and allows letter selection.
- **AC6**: Confirmation status shows **"Resolved-Completed"** after submission.
- **AC7**: Letters/forms in CMOD display correct branding and partner logo after batch.

## Business Flow (Happy Path)

**Actor:** CSR user  
**System:** Casper (call center app), CMOD (letters repository)  
**Environment URL:** `https://it-v8-prpccallcenter.us.bank-dns.com/prweb`  

**Precondition:**

- Test account **must NOT have a co-applicant**.
- Example account (for test): `1234`.

---

### Scenario: Verify branding during interaction and correspondence (UI flow only)

1. CSR navigates to jasper URL.
2. CSR logs in with:
   - Username: `user`
   - Password: `pwd`
3. Casper Dashboard displays.
4. CSR starts an interaction:
   - Clicks **Start Interaction**.
   - Selects **Inbound Phone Call** from the dropdown.
5. CSR searches for account:
   - Expands **Advanced Search**.
   - Selects **Unique ID** tab.
   - Types/pastes `1234` in the **Unique ID** section.
   - Clicks **Submit**.
6. System loads the account and displays product details:
   - Product description is visible.
   - FI / Partner information is visible.
7. CSR validates that **branding is correct** for product description and partner.
8. CSR proceeds with verification:
   - Selects **Contact: Applicant**.
   - Clicks **Submit**.
   - Selects 2–3 verification options.
   - Clicks **Submit**.
9. **Account Summary** page displays.

### Scenario: Start General Correspondence for the account (UI flow)

1. From Account Summary, CSR clicks **Add Task**.
2. CSR selects **Request General Correspondence**.
3. CSR clicks **Add Tasks**.
4. **General Correspondence** workflow displays.
5. CSR selects the following letters/forms:
   - Account Status and Balance (Letter **20044**)
   - AutoPay Form (Letter **20042**)
   - Cardmember Agreement
   - Legal Name Change (Letter **10003**)
6. CSR clicks **Submit** to confirm the changes.
7. Confirmation status **"Resolved-Completed"** displays.
8. CSR clicks **Confirm**.
9. CSR clicks **Wrap Up**.
10. CSR clicks **Submit**.
11. Wrap Up completes successfully.

### Scenario (Batch / CMOD validation – usually manual or separate job)

> This part is often not suitable for a single Playwright test run and may be validated by a later job or a separate check.

1. After the next batch is processed,
2. CSR validates letters in **CMOD**.
3. Letters/forms display correct branding and partner logo where relevant.


Planner prompt:
“You are a Playwright Test Planner.

Read the full story in stories/CASPER-Branding-No-Coapplicant.md and create a comprehensive test plan as Markdown.

Requirements:

Cover all Acceptance Criteria AC1–AC7.

Create at least 3 separate test cases:

Login + branding validation in Casper (no co-applicant)

General Correspondence workflow and confirmation status

(Optional / separate) a placeholder test for CMOD verification that can be implemented later or treated as manual.

For each test, use this structure:

## Test N: Title

Preconditions

Steps

Expected results

Do not skip any acceptance criteria. Return only the Markdown plan.”


Generator prompt:
“You are a Playwright Test Generator.

Using plans/CASPER-Branding-No-Coapplicant.plan.md as the source of truth, generate Playwright TypeScript tests that implement all UI-automatable test cases (login, Casper branding, General Correspondence flow).

Requirements:

Create a single file: tests/CASPER-Branding-No-Coapplicant.spec.ts.

Assume baseURL is set in playwright.config.ts to the Casper environment URL. Use relative paths where possible.

Use robust locators (getByRole, getByLabel, getByPlaceholder, getByTestId) instead of fragile CSS/xpath.

Use Playwright’s auto-wait expectations like await expect(locator).toBeVisible() instead of fixed timeouts.

Treat the CMOD / batch verification as a separate test that can be marked test.skip with a comment that it is validated by a separate process.

Save the final code to tests/CASPER-Branding-No-Coapplicant.spec.ts.”

Healer prompt:
“You are a Playwright Test Healer.

The tests in tests/CASPER-Branding-No-Coapplicant.spec.ts are failing with these errors:

<paste the short error log here>


Please:

Repair the locators or add appropriate waits using await expect(...).toBeVisible() / toHaveText, etc.

Do not change the business intent or acceptance criteria.

Avoid adding waitForTimeout except as a last resort.

Keep tests split by scenario as defined in the plan.

Update the test file in place.”


